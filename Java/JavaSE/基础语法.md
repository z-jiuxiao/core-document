# 基础语法

## 标识符

程序员可以自定义、随意修改的单词为标识符。

- 标识符不能以数字开头
- 标识符可以是任意一个国家的语言
- 标识符只能使用`_和$`两个特殊符号

## 关键字

一些提前被赋予特殊含义的单词，这些关键字不能作为标识符使用。这些关键字有特殊的使用位置以及顺序，程序员无法修改

## 字面量

能够在程序中直接使用的，不需要转换的数据称为字面量

## 变量

在程序运行过程中值可以随意的发生变化

```java
// 变量的定义
数据类型 变量 = 值;
```

作用：

- 一次定义，多处使用
- 维护性强，可读性高

作用域：又称`生命周期`，一个变量从定义为出生，到`所在的{}`执行完为死亡。

```java
public class myClass{
    public static void main(String[] args){
        int i = 0; // i变量出生
        //....
        //...
        if(true) {
            // i变量未死亡，可以访问
        }
    } // 执行完i变量死亡
    // i变量已经死亡，所以这里访问不到
}
```

变量的分类：

- 局部变量
  - 方法体
  - 代码块
  - 参数
- 成员变量
  - 静态变量
  - 实例变量

## 进制

### 进制转换

- 二进制：有一些0和1组成，例如：100101
- 八进制：从0~7，例如：240111
- 十进制：从0~9，例如：325211
- 十六进制：从0~F，例如：CA021

**二进制转换成十六进制：**

- 将二进制从右至左每四个为一组，不足前面补0
- 将每组二进制计算出对应的十六进制

 <img src="https://cdn.jsdelivr.net/gh/z-jiuxiao/imgPicGo/img/202401232039533.png" alt="image-20240123203859420" style="zoom:67%;" />

**十六进制转换二进制：**

- 将每个十六进制转换成十进制
- 十进制除以2取余数，计算出若干组二进制，每四个为一组，不足的前面补0

 <img src="https://cdn.jsdelivr.net/gh/z-jiuxiao/imgPicGo/img/202401232058377.png" alt="image-20240123205847337" style="zoom:67%;" />

### 源码、反码、补码

>  计算机底层存储的数据为二进制的补码

**byte(字节)与bit(比特)：**

- 关系：一个二进制位就是一个bit，每八个bit就是一字节。1byte = 8bit
- 计算机`存储数据最小单位`为1byte，计算机`最小计算单位`为1bit
- 每8个bit最高位为`符号位`，0代表正数，1代表负数

**正数的源码、反码、补码：**

- 正数的源码、反码、补码`一致`
- 例如：5
  - 源码：00000101
  - 反码：00000101
  - 补码：00000101

**负数的源码、反码、补码：**

- 例如：-20
  - 源码*(符号位变1)*：10010100
  - 反码*(符号位不变，其余位置取反)*：11101011
  - 补码*(符号位不变，+1)*：11101100

> 补码转换成源码：补码除符号位全部取反后+1

**1byte取值范围：**

- -128~127

- 256种结果

#### 计算机底层存储补码的原因

例如：-3+2

**存储源码时计算：**

 ![1706103494929](https://cdn.jsdelivr.net/gh/z-jiuxiao/imgPicGo/img/202401242211948.jpg)

**存储补码时计算：**

![image-20240124221514281](https://cdn.jsdelivr.net/gh/z-jiuxiao/imgPicGo/img/202401242215332.png) 

## 数据类型

### 分类

- 整数类型：
  - byte：1字节，默认值0
  - short：2字节，默认值0
  - int：4字节，默认值0
  - long，8字节，默认值0L
- 浮点数类型
  - float：4字节，默认值0.0
  - double：8字节，默认值0.0
- 布尔类型
  - boolean：1字节，默认值false
- 字符类型
  - char：2字节，默认值/u000(空格)

大小：byte < short < int < long < float < double

> 其余都是引用数据类型

**一个类型后面可以定义多个变量**

```java
int a = 10, b = 1;
```

### 类型转换

> **所有数据类型皆是**

- 自动类型转换：小容量会自动转换为大容量
- 强制类型转换：需要程序员使用"强制类型转换符"，从而让大容量转换为小容量
  - 有可能会造成精度丢失，具体看数值的真实大小

```java
public static void main(String[] args) {
    // 自动类型转换
    int a = 1;
    long b = a;

    // 强制类型转换
    long c = 1000;
    int d = (int) c;
}
```

### 整数

- 所有字面量数值默认的数据类型为`int`

- 计算结果的数据类型取`计算数值中最大的数据类型`
- 如果只有byte和short之间的计算，取值的数值类型为int

```java
public static void main(String[] args) {
    byte a = 1;
    int b = 2;
    long c = 10L;
    long result = a + b + c;
}
```

- 字面量数值会在编译阶段进行运算，不会出现类型转换

```java
public static void main(String[] args) {
    // 10和3是字面量，在编译阶段已经将结果计算出来并赋值给a
    // 因为3在byte取值范围中，可以直接使用byte类型接收
    byte a = 10 / 3;
    System.out.println(a);

    // b和c都是变量，编译器会将b和c转换成int类型进行计算，所以取值的数据类型为int类型
    byte b = 10;
    byte c = 3;
    // byte result = b / c;
    int result = b / c;
}
```

- java中进制表示整数

```java
// 二进制
int a = 0b10; // ==>2
// 八进制
int b = 010; // ==>8
// 十进制
int c = 10; // ==>10
// 十六进制
int d = 0x10; // ==>16
```

### 浮点数

- 所有字面量数值默认的数据类型为`double`，设置float类型字面量时需在数值后面添加F/f
- 表示方式

```java
// 十进制
double z = 1.2;
double x = .1; // 整数部分是0可以省略
// 科学计数法：E后面的数字2的x次幂
double j = 1.231E2; // 1.231 * 2的平方
double k = 122.1234E-2; // 122.1234 / 2的平方
```

- 浮点数数值都是`近似值`，计算出的结果不能使用"=="比较，结果永远是false

```java
System.out.println(1.2 - 0.1);// 1.0999999999999999
```

> float类型占的字节大于long类型原因：
>
> - float底层存储中有着占据8bit位的`指数位`，进制上代表的数值是多少就代表2的x次幂，最高为2的127次幂
> - long类型最高为2的63次幂-1
> - 所以：float > long

### 字符

- 转义符

```java
char a = '\t'; //制表符(tab)
char b = '\n'; //换行符
char c = '\''; //单引号
char d = '\"'; //双引号
char e = '\\'; // "\"
char z = '\uxxxx'; //表示Unicode码
```

- 编码
  - ASICII：基础，A(65)~Z，a(98)~z，0(48)~9，特殊字符，一个字节
  - Unicode：十六进制，2或4个字节
  - UTF-8：根据数值使用1~4个字节
  - GBK：汉字，2个字节

> Java中char类型使用的编码为Unicode
>
> `在进行运算时会转换成ASCII对应的码值`

- 表示方式

```java
// 使用字符
char s = 'A';
// 使用Unicode码
char z = '\u0041';
// 使用ASCII码
char y = 65;
```

- 乱码

编码和解码用的不是同一个编码形式

### 布尔

所有判断后的结果都为boolean值 --》false/true

## 运算符

### 算术运算符

- +：数字间做运算，字符串中做拼接
- -：数字相减
- /：数字相除
- %：取余数--》公式`x - x / y * y`

- ++：自身加1
- --：自身减1

++/--执行原理

- 当++在数值`后面`：先赋值，后自增

```java
public static void main(String[] args){
    int x = 1;
    int y = x++;
}
/*
	对应字节码（底层执行顺序）
	public static void main(java.lang.String[]);
    Code:
       0: iconst_1  --》将1加载到操作数栈
       1: istore_1  --》栈最顶的元素弹出并将数据赋值到局部变量表中的1号槽位
       2: iload_1	--》1号槽位的数据复制一份加载到操作数栈
       3: iinc          1, 1  --》1号槽位的数据加1
       6: istore_2  --》栈最顶的元素弹出并将数据赋值到局部变量表中的2号槽位
       7: return
*/
```

- 当++在数值`前面`：先自增，后赋值

```java
public static void main(String[] args){
    int x = 1;
    int y = ++x;
}
/*
	public static void main(java.lang.String[]);
    Code:
       0: iconst_1	--》将1加载到操作数栈
       1: istore_1  --》栈最顶的元素弹出并将数据赋值到局部变量表中的1号槽位
       2: iinc          1, 1  --》1号槽位的数据加1
       5: iload_1	--》1号槽位的数据复制一份加载到操作数栈
       6: istore_2	--》栈最顶的元素弹出并将数据赋值到局部变量表中的2号槽位
       7: return
*/
```

### 逻辑运算符

- &：逻辑与，运算符两边的判断结果都为true，那么最终结果为true；否则为false
- |：逻辑或，运算符两边的判断结果有一方为true，那么最终结果为true；否则为false

- ^：逻辑异或，运算符两边的判断结果不相同为true，否则为false
- !：取反，判断结果取反

- &&：短路与，运算符两边的判断结果都为true，那么最终结果为true；否则为false。如果运算符左边为false，后面表达式不执行
- ||：短路或，运算符两边的判断结果有一方为true，那么最终结果为true；否则为false。如果运算符左边为true，后面表达式不执行

### 位移运算符

> 位移运算符只针对`整数`操作

- <<：左移，数值对应的二进制整体向左移动n位。
  - 1<<2：1对应的二进制向左移动两位。
  - 移动后最右边补0，割除溢出的进制位，符号位不变
  - x<<n ==》x*2的n次幂
- `>>`：右移，数值对应的二进制整体向右移动n位。
  - 1>>2：1对应的二进制向右移动两位
  - 如果数值是负数移动后最左边补1，反之补0，割除溢出的进制位
  - x<<n ==》x/2的n次幂
- `>>>`：无符号右移，数值对应的二进制整体向右移动n位
  - 1>>>3：1对应的二进制位向右移动三位
  - 移动后无论负数还是整数最左边补0，割除溢出的进制位
- &：按位与，两个数值对应的进制位都为1，此进制位结果为1，反之为0
- |：按位或：两个数值对应的进制位只要一方有1，此进制位结果为1，反之为0
- ^：按位异或：两个数值对应的进制位不相同，此进制位结果为1，反之为0
- ~：按位取反：数值对应的进制全部取反

### 条件运算符

运算表达式：`布尔表达式 ? 表达式1 : 表达式2`

如果布尔表达式结果为true，结果取表达式1，反之结果取表达式2

## 控制语句

### 分支语句

#### if

写法：

```java
// 第一种写法
if() {}
// 第二种写法
if(){
}else{}
// 第三种写法
if(){
}else if(){
}else if(){}
// 第四种写法
if(){
}else if(){
}else if(){
}else{}
```

- `()`中的表达式必须是`布尔表达式`
- `else{}`分支为兜底分支，上面分支都不执行，那么执行else{}

- 执行顺序为`从上至下`，上面表达式结果为false就会向下执行，有一个表达式中的`{}`执行完，整个语句执行完毕

#### switch

写法：

```java
switch (表达式) {
    case value1:
        // 表达式的结果和value1相同，执行这里...
        break;
    case value2:
        // 表达式的结果和value2相同，执行这里...
        break;
    default:
        // 表达式的结果和上面都不相同，执行这里...
}
```

- 表达式中只能写`int、Enum、String`三种类型，String类型为JDK1.7之后加入。也可以写互相转换类型，比如：byte，short，char(会自动转换成int)
- 表达式中的结果和value**n**相同，就会执行所属的代码块，都不相同则执行`default`中代码块。default省略则不执行任何东西
- 如果功能相同，case可以进行合并：`case value1: case value2:`，表达式结果是value1或者value2都会执行
- 省略break可能会放生`case穿透`---》继续向下执行，直到遇到break或者switch结束
- 数值不能使用`变量`，只能使用字面量
- `JDK12`之后引入lambda表达式写法

```java
switch (表达式) {
    case value1 -> System.out.println("1");
    case value2 -> System.out.println("2");
    default -> System.out.println("默认");
}
switch (1) {
    case 1,2 -> System.out.println("1");
    default -> System.out.println("默认");
}
switch (1) {
    case 1,2 -> {
        System.out.println("1");
    }
    default -> System.out.println("默认");
}
```

### 循环语句

#### for

- 写法

```java
for(初识表达式; 布尔表达式; 更新表达式) {
    // 循环体
}
for(int i = 0;i<10; i++) {
    // 循环体
}
```

- **执行原理**

①初识表达式，②布尔表达式，③更新表达式，④循环体

先执行①，再执行②如果结果为true执行④；

然后执行③，接着执行②，如果结果还为true继续执行④；

一直循环，知道②结果为false。

> ①-->②-->true-->④-->③-->②-->true-->④--->③-->②--false-->循环结束

- 死循环写法

```java
for(;;) {
    // 循环体
}
```

#### while

- 写法

```java
while(布尔表达式) {
    // 循环体
}
```

- 执行原理

当表达式结果为true就执行循环体，直接表达式结果为false整个循环结束。

循环的次数为0~n次

#### do--while

- 写法

```java
do{
	// 循环体
}while(布尔表达式);
```

- 执行原型

先执行一次循环体，然后执行表达式，当表达式结果为true就执行循环体，直接表达式结果为false整个循环结束。

循环的次数为1~n次

### 跳转语句

#### break

终止最近的循环

#### continue

终止此次循环，执行下一次循环(跳过这次循环)。针对最近的循环

- break和continue可以指定某一个循环

```java
for1:for(int i = 0; i < 2; i++) {
    for2:for(int j = 0; j < 10; j++){
        break/continue for1/for2;
    }
}
```

#### return

停止当前方法

## 方法

- 定义

```java
[修饰符列表] 返回值类型 方法名(形参) {
    // 方法体
}
```



















